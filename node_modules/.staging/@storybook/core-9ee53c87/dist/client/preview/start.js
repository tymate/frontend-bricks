"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = start;
exports.getContext = void 0;

var _addons = _interopRequireDefault(require("@storybook/addons"));

var _global = require("global");

var _channelPostmessage = _interopRequireDefault(require("@storybook/channel-postmessage"));

var _clientApi2 = require("@storybook/client-api");

var _utils = require("@storybook/router/utils");

var _clientLogger = require("@storybook/client-logger");

var _coreEvents = _interopRequireDefault(require("@storybook/core-events"));

var _utilDeprecate = _interopRequireDefault(require("util-deprecate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var classes = {
  MAIN: 'sb-show-main',
  NOPREVIEW: 'sb-show-nopreview',
  ERROR: 'sb-show-errordisplay'
};

function showMain() {
  _global.document.body.classList.remove(classes.NOPREVIEW);

  _global.document.body.classList.remove(classes.ERROR);

  _global.document.body.classList.add(classes.MAIN);
}

function showNopreview() {
  _global.document.body.classList.remove(classes.MAIN);

  _global.document.body.classList.remove(classes.ERROR);

  _global.document.body.classList.add(classes.NOPREVIEW);
}

function showErrorDisplay(_ref) {
  var message = _ref.message,
      stack = _ref.stack;
  _global.document.getElementById('error-message').textContent = message;
  _global.document.getElementById('error-stack').textContent = stack;

  _global.document.body.classList.remove(classes.MAIN);

  _global.document.body.classList.remove(classes.NOPREVIEW);

  _global.document.body.classList.add(classes.ERROR);
} // showError is used by the various app layers to inform the user they have done something
// wrong -- for instance returned the wrong thing from a story


function showError(_ref2) {
  var title = _ref2.title,
      description = _ref2.description;

  _addons["default"].getChannel().emit(_coreEvents["default"].STORY_ERRORED, {
    title: title,
    description: description
  });

  showErrorDisplay({
    message: title,
    stack: description
  });
} // showException is used if we fail to render the story and it is uncaught by the app layer


function showException(exception) {
  _addons["default"].getChannel().emit(_coreEvents["default"].STORY_THREW_EXCEPTION, exception);

  showErrorDisplay(exception); // Log the stack to the console. So, user could check the source code.

  _clientLogger.logger.error(exception.stack);
}

var isBrowser = _global.navigator && _global.navigator.userAgent && _global.navigator.userAgent !== 'storyshots' && !(_global.navigator.userAgent.indexOf('Node.js') > -1) && !(_global.navigator.userAgent.indexOf('jsdom') > -1);

var getContext = function () {
  var cache;
  return function (decorateStory) {
    if (cache) {
      return cache;
    }

    var channel = null;

    if (isBrowser) {
      try {
        channel = _addons["default"].getChannel();
      } catch (e) {
        channel = (0, _channelPostmessage["default"])({
          page: 'preview'
        });

        _addons["default"].setChannel(channel);
      }
    }

    var storyStore;
    var clientApi;

    if (typeof _global.window !== 'undefined' && _global.window.__STORYBOOK_CLIENT_API__) {
      clientApi = _global.window.__STORYBOOK_CLIENT_API__; // eslint-disable-next-line no-underscore-dangle

      storyStore = clientApi._storyStore;
    } else {
      storyStore = new _clientApi2.StoryStore({
        channel: channel
      });
      clientApi = new _clientApi2.ClientApi({
        storyStore: storyStore,
        decorateStory: decorateStory
      });
    }

    var _clientApi = clientApi,
        clearDecorators = _clientApi.clearDecorators;
    var configApi = new _clientApi2.ConfigApi({
      clearDecorators: clearDecorators,
      storyStore: storyStore,
      channel: channel,
      clientApi: clientApi
    });
    return {
      configApi: configApi,
      storyStore: storyStore,
      channel: channel,
      clientApi: clientApi,
      showMain: showMain,
      showError: showError,
      showException: showException
    };
  };
}();

exports.getContext = getContext;

function focusInInput(event) {
  return /input|textarea/i.test(event.target.tagName) || event.target.getAttribute('contenteditable') !== null;
}

function start(render) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      decorateStory = _ref3.decorateStory;

  var context = getContext(decorateStory);
  var clientApi = context.clientApi,
      channel = context.channel,
      configApi = context.configApi,
      storyStore = context.storyStore; // Provide access to external scripts if `window` is defined.
  // NOTE this is different to isBrowser, primarily for the JSDOM use case

  var previousKind = '';
  var previousStory = '';
  var previousRevision = -1;

  var renderMain = function renderMain(forceRender) {
    var revision = storyStore.getRevision();
    var selection = storyStore.getSelection();

    var _ref4 = selection || {},
        kind = _ref4.kind,
        name = _ref4.name,
        getDecorated = _ref4.getDecorated,
        id = _ref4.id;

    if (getDecorated) {
      // Render story only if selectedKind or selectedStory have changed.
      // However, we DO want the story to re-render if the store itself has changed
      // (which happens at the moment when HMR occurs)
      if (!forceRender && revision === previousRevision && kind === previousKind && previousStory === name) {
        _addons["default"].getChannel().emit(_coreEvents["default"].STORY_UNCHANGED, id);

        return;
      }

      if (!forceRender && previousKind && previousStory) {
        _addons["default"].getChannel().emit(_coreEvents["default"].STORY_CHANGED, id);
      }

      render(Object.assign({}, context, selection, {
        selectedKind: kind,
        selectedStory: name,
        forceRender: forceRender
      }));

      _addons["default"].getChannel().emit(_coreEvents["default"].STORY_RENDERED, id);
    } else {
      showNopreview();

      _addons["default"].getChannel().emit(_coreEvents["default"].STORY_MISSING, id);
    }

    previousRevision = revision;
    previousKind = kind;
    previousStory = name;

    if (!forceRender) {
      _global.document.documentElement.scrollTop = 0;
    }
  }; // initialize the UI


  var renderUI = function renderUI(forceRender) {
    if (isBrowser) {
      try {
        renderMain(forceRender);
      } catch (ex) {
        showException(ex);
      }
    }
  };

  var forceReRender = function forceReRender() {
    return renderUI(true);
  }; // channel can be null in NodeJS


  if (isBrowser) {
    var deprecatedToId = (0, _utilDeprecate["default"])(_utils.toId, "Passing name+kind to the SET_CURRENT_STORY event is deprecated, use a storyId instead");
    channel.on(_coreEvents["default"].FORCE_RE_RENDER, forceReRender);
    channel.on(_coreEvents["default"].SET_CURRENT_STORY, function (_ref5) {
      var inputStoryId = _ref5.storyId,
          name = _ref5.name,
          kind = _ref5.kind;
      var storyId = inputStoryId; // For backwards compatibility

      if (!storyId) {
        if (!name || !kind) {
          throw new Error('You should pass `storyId` into SET_CURRENT_STORY');
        }

        storyId = deprecatedToId(kind, name);
      }

      var data = storyStore.fromId(storyId);
      storyStore.setSelection(data);
      storyStore.setPath(storyId);
    }); // Handle keyboard shortcuts

    _global.window.onkeydown = function (event) {
      if (!focusInInput(event)) {
        // We have to pick off the keys of the event that we need on the other side
        var altKey = event.altKey,
            ctrlKey = event.ctrlKey,
            metaKey = event.metaKey,
            shiftKey = event.shiftKey,
            key = event.key,
            code = event.code,
            keyCode = event.keyCode;
        channel.emit(_coreEvents["default"].PREVIEW_KEYDOWN, {
          event: {
            altKey: altKey,
            ctrlKey: ctrlKey,
            metaKey: metaKey,
            shiftKey: shiftKey,
            key: key,
            code: code,
            keyCode: keyCode
          }
        });
      }
    };
  }

  storyStore.on(_coreEvents["default"].STORY_RENDER, renderUI);

  if (typeof _global.window !== 'undefined') {
    _global.window.__STORYBOOK_CLIENT_API__ = clientApi;
    _global.window.__STORYBOOK_ADDONS_CHANNEL__ = channel; // may not be defined
  }

  return {
    context: context,
    clientApi: clientApi,
    configApi: configApi,
    forceReRender: forceReRender
  };
}